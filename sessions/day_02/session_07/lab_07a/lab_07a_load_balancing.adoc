:compat-mode:
= Lab 07a - Client-Side Load Balancing with Ribbon

Estimated time to complete: 30 minutes
[abstract]
--
Let's continue learning the components found in Spring Cloud to implement patterns for distributed systems.
We'll again use Spring Cloud Netflix to implement client-side load balancing with Ribbon.

In this lab, we'll do the following:

. Change the consumer application from link:../../session_06/lab_06b/lab_06b_discovery.adoc[Lab 06b] to:
.. Use a `LoadBalancerClient`
.. Use a `RestTemplate` configured to resolve service names from Ribbon
. Test the new consumer versions against our local pool of producers
. Try swapping out the Ribbon load balancing algorithm
--

NOTE: before starting this lab, you can stop all the applications you had started in the previous labs. You will not need them anymore.

This lab uses 4 running applications. Here is a table that you can refer to during the lab.

|=======
|Eureka |http://localhost:8761
|Producer 1 |http://localhost:8080
|Producer 2 |http://localhost:8082 
|Consumer|http://localhost:8091
|=======



== Setup

. Four projects have been placed inside `$COURSE_HOME/day_02/session_07/lab_07a/initial/`. Import all of them inside your IDE of choice.

. Eureka: Open `springtrader-eureka` and launch the class `SpringtraderEurekaApplication`

. Connect to http://localhost:8761/ to confirm that Eureka has been started successfully. 

. A completed `springtrader-producer` project has been placed in `$COURSE_HOME/day_02/session_06/lab_07a/initial/springtrader-producer` for your convenience.
Change to that directory and build
+
----
cd $COURSE_HOME/day_02/session_07/lab_07a/initial/springtrader-producer
mvn clean package
----

. Now run the producer twice (on different ports), each in a different terminal/command window:
+
----
Linux, MacOS:
$ SERVER_PORT=8080 java -jar target/lab_07a-springtrader-producer-0.0.1-SNAPSHOT.jar
$ SERVER_PORT=8082 java -Deureka.instance.metadataMap.instanceId=p8082 -jar target/lab_07a-springtrader-producer-0.0.1-SNAPSHOT.jar

Windows:
> set SERVER_PORT=8080
> java -jar target/lab_07a-springtrader-producer-0.0.1-SNAPSHOT.jar
> set SERVER_PORT=8082
> java -Deureka.instance.metadataMap.instanceId=p8082 -jar target/lab_07a-springtrader-producer-0.0.1-SNAPSHOT.jar
----

. Ensure you have two instances of the producer service registered in Eureka on http://localhost:8761 :
+
image::../../../Common/images/ribbon_1.png[]

== Using the `LoadBalancerClient`

. Inside your IDE, open the project `springtrader-consumer`

. Where is Ribbon?
+
You might be interested to know how your Ribbon Client has been included inside your project so it can be used by our Consumer. Inside your `pom.xml` file, you will find the following dependency:

+
[source,xml]
----
<dependency>
	<groupId>org.springframework.cloud</groupId>
	<artifactId>spring-cloud-starter-eureka</artifactId>
</dependency> 
----

The `spring-cloud-starter-eureka` dependency transitively comes with the `Ribbon` libraries (you will find them in your list of `jar` files).


. In `io.springtrader.consumer.ConsumerController`, copy the `consume()` method as per below:
+
[source,java]
----
@RequestMapping(value="/", produces="application/json")
    public String consume() {
                
        ProducerResponse response = restTemplate.getForObject("http://producer", ProducerResponse.class);
        return String.format("{\"server port\":%d, \"value\":%d}", response.getServerPort(), response.getValue());
        
    }
----

. Run your application by launching `SpringtraderConsumerApplication`. 

. Connect to http://localhost:8091/ and access the consumer application several times. Per the round-robin algorithm, 50% if the requests should be served by producer 8080 (and the other half should go to producer 8082).

+
[source,json]
----
{
   "server port":8082,
   "value":4
}
----


== Trying Different Load Balancing Algorithms

In this section we will swap the default ``round robin'' load balancing rule for a ``weighted response time'' load balancing rule.

. In the package `io.springtrader.consumer`, create the class `RibbonConfiguration`, and into that class paste the following code:
+
[source,java]
----
@Configuration
public class RibbonConfiguration {

    @Bean
    public IClientConfig ribbonClientConfig() {
        DefaultClientConfigImpl config = new DefaultClientConfigImpl();
        config.loadProperties("producer");
        return config;
    }

    @Bean
    public IRule ribbonRule(IClientConfig config) {
        WeightedResponseTimeRule rule = new WeightedResponseTimeRule();
        rule.initWithNiwsConfig(config);
        return rule;
    }
}
----

. Add the `@RibbonClient` annotation to `io.springtrader.consumer.SpringtraderConsumerApplication`:
+
[source,java]
----
@SpringBootApplication
@EnableDiscoveryClient
@RibbonClient(name = "producer", configuration = RibbonConfiguration.class)  // <--- ADD THIS!
public class SpringtraderConsumerApplication {

    public static void main(String[] args) {
        SpringApplication.run(SpringtraderConsumerApplication.class, args);
    }
}
----

. Restart the consumer application by launching again  `SpringtraderConsumerApplication`. At this stage, your requests should be still served per the round-robin algorithm (requests are share equally between both `producer` instances.

. We are now moving to the `springtrader-producer` project. Let's introduce artificial latency into the producer application to cause the load balancer to prefer one instance over the other (on the average).
Inside your `producer` project, modify `io.springtrader.producer.ProducerController` by pasting in the following source code:
+
[source,java]
----
@RestController
public class ProducerController {

    @Value("${latency:0}") // <1>
    int latency;

    private Log log = LogFactory.getLog(ProducerController.class);
    private AtomicInteger counter = new AtomicInteger(0);

    @RequestMapping(value = "/", produces = "application/json")
    public String produce() {
        if (latency > 0) {
            try {
                Thread.sleep(latency);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        int value = counter.getAndIncrement();
        log.info("Produced a value: " + value);

        return String.format("{\"value\":%d}", value);
    }

}
----
<1> The expression `${latency:0}` will inject the value of the `latency` property from the environment.
If that property is not present, it will inject `0`.
====

. Rebuild the application:
+
----
$ mvn clean package
----

. In the two separate terminal windows running the producers, restart the applications while introducing the `LATENCY` environment variable:
+
----
Linux, MacOS:
$ LATENCY=250  SERVER_PORT=8080 java -jar target/lab_07a-springtrader-producer-0.0.1-SNAPSHOT.jar
$ LATENCY=1000 SERVER_PORT=8082 java -Deureka.instance.metadataMap.instanceId=p8082 -jar target/lab_07a-springtrader-producer-0.0.1-SNAPSHOT.jar

Windows:
> set SERVER_PORT=8080
> set LATENCY=250 
> java -jar target/lab_07a-springtrader-producer-0.0.1-SNAPSHOT.jar
> set SERVER_PORT=8082
> set LATENCY=1000 
> java -Deureka.instance.metadataMap.instanceId=p8082 -jar target/lab_07a-springtrader-producer-0.0.1-SNAPSHOT.jar
----

. Open the `consumer` application console.
You should see log messages indicating that the load balancer has started calculating weights:
+
----
2015-02-24 09:14:49.617  INFO 86301 --- [tTimer-producer] c.n.l.WeightedResponseTimeRule           : Weight adjusting job started
2015-02-24 09:14:49.617  INFO 86301 --- [nio-8081-exec-1] c.n.l.WeightedResponseTimeRule           : Weight adjusting job started
2015-02-24 09:14:49.647  INFO 86301 --- [nio-8081-exec-1] c.n.l.WeightedResponseTimeRule           : Weight adjusting job started
----

. Use the `hitIt.sh` script located at `$COURSE_HOME/day_02/session_07/lab_07a/initial/hitIt.sh` at to issue many requests to the consumer.
You will see very different load balancing behavior from the original:
+
----
$ ./hitIt.sh localhost:8081 1000
----
